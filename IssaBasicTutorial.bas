Язык разработан для начинающих программистов, но он так же должен позволять им программировать на нём дальше сложные и сверхсложные проекты.

Простой, понятный язык с широкими возможностями.



1. Простой синтаксис, однако должен поддерживать объекты. За основу взят - BASIC.
2. Язык должен транслироваться в другие языки программирования. Для этого он должен иметь класс, перегрузив методы к-го можно сгенерировать любой код.
3. Позволять декларировать функции из сторонних dll
4. Должны быть: многомерные массивы, списки и хеши. Просто a(1, 55..66, "abc")
4. Хеши
5. Все переменные - локальные. Никаких var.
6. Автозагрузка классов
7. Не надо использовать имена функций, которые ассоциируются

== Регистр идентификаторов

Идентификаторы регистронезависимы

== Переменные

Состоят из одной буквы.

a или A

== Присваивание реализуется методами

Левостороннее:

	a = 1
	let a = 1

правостороннее:

	6 into k
	6 as k


== Выражение

Любая строка, не начинающаяся на ключевое слово: rem, for, next, repeat, until или др. является вызовом функции.


== Комментарии


== Константы

a тождественно 1. Если нет - выскочит исключение
	
	a == 1

То же самое:

	(a = 1) assert
	assert a = 1

assert можно использовать для проверки любых условий.


== Условия

В условиях оператор "=" считается сравнением.

=== Однострочный if

if [условие] [[,] then] []

rem Если можно
if "123" = '123' then print "True"


=== Ограничения

| условие1, выбор1
| условие2, выбор2
...

Выполняется только первое условие.
Если ни одно условие не удовлетворится, то выскочит исключение.

== Циклы

Циклы именуются через переменную.
Для выхода из цикла нужно использовать 

=== for

for переменная=выражение
	...
next переменная

Выражения могут быть самыми разнообразными
[to выр.] [step выр.] [while|until условие] [if условие]


==== Итеративный for

for i = 1 to 10 step 2
print i
next i

for i = 10 downto 0 step -2
print i
next i

c = 1
for i = 1 into 10 step c
if i = 2 then c=-1
print i
next i

=== Генератор

r = 1 to 10 as x map [ x + 10 ]
print "Массив от 11 до 20:"; r

=== repeat

repeat [переменная[=выр.]]
... 
until [условие]


print "цикл repeat: "
repeat i=0

i + 1

print i,

until i=10


Бесконечный цикл:
repeat i=0
print i++;
until


== ООП

Каждый файл считается классом. А Весь код до первого метода - его конструктором.

Константы и значения переменных - объекты.

=== Создание объекта

Новый объект порождает его конструктор:

a = 

=== Метод

Объявление метода - строка заканчивающаяся на ":".
Конец метода - конец файла, либо описание другого метода с ":", либо до ключевого слова class.

swap a, b:
c=b
b=a
a=c



Однострочный метод, который не перекрывает c ":":

fib 0 = 0
fib 1 = 1
fib n = fib(n-1) + fib(n-2)


==== Конструктор

Код до первого метода - конструктор.

==== Деструктор

destroy:
...


==== Перегрузка операторов

Для перегрузки оператора напишите метод с названием оператора в кавычках ("")

"+" b:
self + int(b)


=== Наследование

Ключевое слово extends позволяет наледовать класс.

class Animal
name:
return ""

class Ret extends Animal
class Dog extends Ret

a = Animal@
r = Ret.
d = Dog.

"" & a@ == "Animal@#123456"
print a.name$

== ООП

== Исключения


== Основные типы данных

=== Масив

Массив содержит все элементы одного типа.

Заполняем элементами двумерную матрицу:
a = [1,2,3; 6,5,4; 3,2,1]


Трёхмерную:

a = [1,2,3; 6,5,4 | 3,2,1; 3 ]


a#
len(a)


=== Список
a = array 1, 2, 3
a first == 1
a last == 3
a(1) == 2

Длина списка:
a# == 2

push:
a()= 4

b = array(14)

Конкантенация
a = array( a*, b* )
a = a+b

a.pop()



=== Хеш

a = a: 10, b: 20, assign: 30

== Регулярные выражения

s = "abcde"
s[^abc] = 10

s == "10de"


== Отложенные до конца функции действия

defer print "Конец функции"


== Модификаторы

Модификаторы - это просто именованные 




== Операторы



=== Операторы приведения

Данные операторы записываются как префиксы переменных или названий методов и определяют их тип.

$ - строка
% - целое
# - двойное число с плавающей точкой
! - 
& -
? -
@ - новый объект

=== Логические


== Замыкания

c = closure a# * b.len

gosub c with  set a: [1, 2], b: [3, 4]


== Функциональное программирование

IssaBasic поддерживает функциональное программирование:

fib 0 = 0
fib 1 = 1
fib n = fib(n-1) + fib(n-2)

=== Сопоставление с образцом

На примере 


=== Отложенные (ленивые) вычисления
Код выполняется при запросе, а не сразу. Это значит, что значения переменных можно поменять.

a = array 1, 2, 3

map a+1 from a into a

a = grep a>0 from a

А вот объявление функции sum:
sum a = reduce a+b from a

И max:
max a = reduce if(a > b, a; b) from a


Сортировка по возрастанию:
sort a<=>b from a into a

Сортировка по убыванию:
sort b<=>a from a into b


map b from a:
for i=a
	b.a=i
	yield b
next i


grep b from a:
for i=a
	b.a=i
	if b yield i
next i


reduce b from a:
x = a(0)
for i=a(1 to a.len)
	b.a=x
	b.b=i
	x=b
next i
ret x

Если b вернёт null, то операция x=b будет проигнорирована.

sort b from a:



== null

Любое выражение с null вернёт null, а присваивание не совершится. Что использовано в функции reduce в примере выше.

a = 1, null, 2

sum(a) == 3
max(a) == 2
min(a) == 1

== Assert

Тождество устанавливается оператором "==". Если оно не верно - выскочит исключение.

a = 3
a == 3


== Исключения

Перехват исключений:

try

except Type as e

except e

finally

end try


Генерация исключения:

throw Exception("сообщение")


== Использование dll

printf(a, b...) = declare printf(a$, b...) from libc

itoa(a) = declare itoa$(a%) from libc

Или другой вариант:

loaddl "libc"

libc.itoa$(10%) == "10"

Таблица типов:
% - i32
%% - i64
%& - i8
%&& - i16
& - u32
&& - u64
&% - u8
&%% - u16
$ - string
$$ - utf8 asciiz
$$ - asciiz
! - float32
# - float64

